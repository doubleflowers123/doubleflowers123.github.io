# Direct3D的初始化


# ***Direct3D的初始化***

## ***预备知识***

*通过 Direct3D 这种底层图形应用程序编程接口（Application Programming Interface，API），即可在 在应用程序中对图形处理器（Graphics Processing Unit，GPU）进行控制和编程。我们能够借此以硬件加 速的方式渲染出虚拟的 3D 场景*

### ***组件对象模型***

*组件对象模型（Component Object Model，COM）是一种令 DirectX 不受编程语言束缚，并且使之向后兼 容的技术。*

*我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。 *

*用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。*

*我们只需知道：要获取指向某 COM 接 口的指针，需借助特定函数或另一COM 接口的方法——而不是用C++语言中的关键字new 去创建一个COM 接口。*

*另外，COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法（COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内），而不是用 delete 来删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。*

### ***纹理格式***

*2D 纹理（2D texture）是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组）。*

*它的用途之 一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。然而，纹理的 用处并非仅此而已。*

*例如，有种称作法线贴图（normal mapping）的高级技术，其纹理内的每个元素存 储的就是一个 3D 向量而不是颜色信息。*

*因此，尽管纹理给人的第一印象通常是用来存储图像数据，但 其实际用途却十分广泛。*

*简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数 组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，纹理其实还不只是像“数据数组”那 样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理，例如运用过 滤器（filter）和进行多重采样（multisample）。另外，并不是任意类型的数据元素都能用于组成纹理， 它只能存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素*

### ***交换链和页面翻转***

*为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏 （off-screen，即不可直接呈现在显示设备上之意）纹理内。*

*只要将指定动画帧的整个场景绘到后台缓冲区 中，它就会以一个完整的帧画面展现在屏幕上；*

*依照此法，观者便不会察觉出帧的绘制过程——而只会 观赏到完整的动画帧。*

*为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的前台缓冲区（front buffer） 和后台缓冲区（back buffer）。*

*前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被 绘制在后台缓冲区里。*

*当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变 为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数 据。前后台缓冲的这种互换操作称为呈现（presenting，亦有译作提交、显示等）。*

*呈现是一种高效的操 作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。*

### ***深度缓冲***

*深度缓冲区（depth buffer）这种纹理资源存储的并非图像数据，而是特定像素的深度信息。*

*深度值 的范围为 0.0～1.0。0.0 代表观察者在视锥体（view frustum， 亦有译作视域体、视景体、视截体或视体等，意即观察者 能看到的空间范围，形如从四棱锥中截取的四棱台，常称 该形为平截头体（frustum，见图 4.3，后文亦有详述））中 能看到离自己最近的物体，1.0 则代表观察者在视锥体中能 看到离自己最远的物体。*

*深度缓冲区中的元素与后台缓冲 区内的像素呈一 一对应关系（即后台缓冲区中第 i 行第 j 列 的元素对应于深度缓冲区内第 i 行第 j 列的元素）。所以， 如果后台缓冲区的分辨率为1280 × 1024  ，那么深度缓冲区 中就应当有1280 × 1024 个深度元素*

### ***资源与描述符***

